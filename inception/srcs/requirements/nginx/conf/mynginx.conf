# Le bloc http est le contexte principal pour le serveur web HTTP(S). Toutes les directives et les blocs qui concernent le traitement des requêtes HTTP et HTTPS doivent être définis à l'intérieur de ce bloc.
# Le fichier de configuration 'par défaut'/'de base'/'déjà présent' de nginx contient déjà ce bloc http, où une directive inclut tous les fichiers '.conf'. 

# Le fichier de configuration de nginx détermine comment il écoute les requêtes, où il trouve les fichiers, comment il gère le traffic, la sécurité,...  
# Composé de directives (comme 'listen') et blocs (comme 'server')

# La directive 'location' permet de définir comment nginx doit traiter les requêtes en fonction de l'URI (partie de l'URL qui suit le nom de domaine). "Si qqun demande cette URI, fais ceci"
# 'root' spécifie le répertoire racine à partir duquel Nginx doit servir les fichiers. Lorsqu'une requête arrive, Nginx combine la valeur de root avec l'URI de la requête pour construire le chemin complet du fichier sur le serveur.
# 'index' définit quels fichiers servir par défaut lorsqu'une requête URI correspond à un répertoire (l'URI se termine par un '/' ou ne spécifie pas de fichier). 
# 'listen' spécifie l'adresse IP et le port sur lesquels nginx doit écouter les requêtes entrantes. Si le port est omis, nginx écoute par défaut sur le port 80. Si l'IP est omise, nginx écoute sur toutes les interfaces réseau de la machine/conteneur

server {
	listen					443 ssl; 						# le serveur doit écouter sur le port 443 du système, qui est le port standard pour https. Le mot-clé "ssl" force l’utilisation de TLS/SSL pour les connexions.
	server_name				gebuqaj.42.fr;					# Spécifie le nom de domaine que ce bloc server doit gérer. Si une requête HTTPS est adressée à gebuqaj.42.fr, elle sera traitée par ce bloc.
	ssl_certificate			/etc/nginx/ssl/inception.crt;	# Fichier contenant le certificat SSL/TLS correspondant au nom de domaine.
	ssl_certificate_key		/etc/nginx/ssl/inception.key;	# Fichier contenant la clef privée. Elle doit rester confidentielle.
	ssl_protocols       	TLSv1.3;						# Spécifie les versions de TLS utilisées

	root 					/var/www/wordpress/;			# Les fichiers seront cherchés dans le dossier '/var/www/wordpress'. Si un utilisateur demande 'http://gebuqaj.42.fr/page.html', nginx servira le fichier '/var/www/wordpress/page.html'
	index					index.php index.html index.htm;	# Nginx cherchera les fichiers (dans le répertoire défini par root) dans l'ordre. Le premier fichier trouvé sera servi. Si le répertoire existe mais aucun fichier listé dans index n’est présent, nginx retourne une erreur 403 (accès refusé). Si le répertoire lui-même n’existe pas, nginx retourne une erreur 404.
	
	error_page 404			/404.html;						# Lorsqu'une erreur 404 se produit, servir '/404.html', le chemin est relatif à root.

	location /mon-site/ {
		index 				mon-premier-site.html;
		try_files $uri $uri/ =404;
	}
	
	location / {											# '/' s'applique à toutes les requêtes
		try_files $uri $uri/ =404;							# D'abord, chercher le fichier exact demandé '$uri'. Si pas trouvé, essayer de voir si c'est un répertoire '$uri/'. En dernier recours, '=' renvoie le code d'erreur 404
	}

	# Nginx ne peut pas exécuter les scripts php lui-même. Il a besoin d'un interpréteur externe comme PHP-FPM (FastCGI Process Manager)
	location ~ \.php$ {										# Pour les requêtes dont le chemin se termine par '.php'
		try_files		$uri =404;
		#proxy_pass		127.0.0.1:3000;						Pour l'exemple. 'proxy_pass' fait suivre les requêtes à un serveur HTTP.
        fastcgi_pass	wordpress:9000;						# 'fastcgi_pass' indique où envoyer la requête. Il ouvre la connexion avec PHP-FPM, mais ne dit pas quoi exécuter. Ici les requêtes sont transmises au port 9000 du SERVICE (et pas conteneur) nommé wordpress.
        include			fastcgi_params;						# Fournit les variables d'environnement de base indispensables au fonctionnement de PHP.
        fastcgi_param	SCRIPT_FILENAME $document_root$fastcgi_script_name;	# indique à PHP-FPM le chemin complet du script PHP à exécuter. 'fastcgi_param' envoie une variable d’environnement à PHP-FPM via le protocole FastCGI. 'SCRIPT_FILENAME' nom de la variable attendue par PHP-FPM pour connaître le fichier à exécuter. '$document_root' variable Nginx: le chemin défini par la directive root. '$fastcgi_script_name'. Variable Nginx: le chemin URI de la requête actuelle (ex: /index.php)
		# Par exemple, un visiteur demande 'http://gebuqaj.42.fr/pages/contact.php'. Alors nginx construit 'SCRIPT_FILENAME = /var/www/wordpress/pages/contact.php'. Ce chemin est transmis à PHP-FPM. Les conteneurs wordpress et nginx partagent le même volume. Sans cette ligne, PHP-FPM ne saurait pas quel script exécuter.
	}
}

# Docker crée un réseau virtuel privé pour nos conteneurs. Chaque conteneur sur ce réseau peut "voir" les autres conteneurs.
# Résolution par Nom de Service: Au lieu d'utiliser des adresses IP qui peuvent changer, Docker permet aux conteneurs de se référer les uns aux autres par leurs noms de service (ceux que vous définissez dans votre docker-compose.yml, par exemple).
# Ainsi, lorsque Nginx (qui est dans son propre conteneur) doit envoyer une requête PHP à PHP-FPM, il utilise simplement le nom du service (wordpress) et le port interne sur lequel PHP-FPM écoute dans ce conteneur (9000)

# Lorsqu'on lance un conteneur avec 'docker run' et qu'on ne spécifie pas le réseau (option '--network'), Docker le connecte par défaut à un réseau appelé 'bridge'. Ce réseau bridge par défaut est créé automatiquement lorsque vous installez et démarrez Docker pour la première fois. Les conteneurs sur ce réseau par défaut peuvent communiquer entre eux, mais uniquement par adresse IP. Ils n'ont pas de résolution de nom de service automatique.
# Lorsque vous utilisez un fichier docker-compose.yml et que vous ne définissez aucune section networks explicite au niveau supérieur, Docker Compose crée automatiquement un réseau bridge par défaut pour l'ensemble de votre application. Ce réseau est nommé en fonction du nom de votre répertoire de projet (par exemple, si votre dossier s'appelle mon_app, le réseau sera mon_app_default).
# Recommandé : Bien que Docker Compose crée ce réseau par défaut pour vous, il est souvent recommandé de définir explicitement vos propres réseaux personnalisés dans votre docker-compose.yml.

